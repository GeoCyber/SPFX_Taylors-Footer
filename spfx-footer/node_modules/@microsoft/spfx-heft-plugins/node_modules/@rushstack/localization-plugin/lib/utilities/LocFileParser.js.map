{"version":3,"file":"LocFileParser.js","sourceRoot":"","sources":["../../src/utilities/LocFileParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { ITerminal, NewlineKind, JsonFile } from '@rushstack/node-core-library';\n\nimport { ILocalizationFile } from '../interfaces';\nimport { ResxReader } from './ResxReader';\nimport { Constants } from './Constants';\n\n/**\n * @internal\n */\nexport interface IParseLocFileOptions {\n  terminal: ITerminal;\n  filePath: string;\n  content: string;\n  resxNewlineNormalization: NewlineKind | undefined;\n  ignoreMissingResxComments: boolean | undefined;\n}\n\ninterface IParseCacheEntry {\n  content: string;\n  parsedFile: ILocalizationFile;\n}\n\nconst parseCache: Map<string, IParseCacheEntry> = new Map<string, IParseCacheEntry>();\n\n/**\n * @internal\n */\nexport class LocFileParser {\n  public static parseLocFile(options: IParseLocFileOptions): ILocalizationFile {\n    const fileCacheKey: string = `${options.filePath}?${options.resxNewlineNormalization || 'none'}`;\n    if (parseCache.has(fileCacheKey)) {\n      const entry: IParseCacheEntry = parseCache.get(fileCacheKey)!;\n      if (entry.content === options.content) {\n        return entry.parsedFile;\n      }\n    }\n\n    let parsedFile: ILocalizationFile;\n    if (/\\.resx$/i.test(options.filePath)) {\n      parsedFile = ResxReader.readResxAsLocFile(options.content, {\n        terminal: options.terminal,\n        resxFilePath: options.filePath,\n        newlineNormalization: options.resxNewlineNormalization,\n        warnOnMissingComment: !options.ignoreMissingResxComments\n      });\n    } else if (/\\.(resx|loc)\\.json$/i.test(options.filePath)) {\n      parsedFile = JsonFile.parseString(options.content);\n      try {\n        Constants.LOC_JSON_SCHEMA.validateObject(parsedFile, options.filePath);\n      } catch (e) {\n        options.terminal.writeError(`The loc file is invalid. Error: ${e}`);\n      }\n    } else if (/\\.resjson$/i.test(options.filePath)) {\n      const resjsonFile: Record<string, string> = JsonFile.parseString(options.content);\n      parsedFile = {};\n      const comments: Record<string, string> = {};\n      for (const [key, value] of Object.entries(resjsonFile)) {\n        if (key.startsWith('_') && key.endsWith('.comment')) {\n          const commentKey: string = key.substring(1, key.length - '.comment'.length);\n          comments[commentKey] = value;\n        } else {\n          parsedFile[key] = { value };\n        }\n      }\n\n      const orphanComments: string[] = [];\n      for (const [key, comment] of Object.entries(comments)) {\n        if (parsedFile[key]) {\n          parsedFile[key].comment = comment;\n        } else {\n          orphanComments.push(key);\n        }\n      }\n\n      if (orphanComments.length > 0) {\n        options.terminal.writeErrorLine(\n          'The resjson file is invalid. Comments exist for the following string keys ' +\n            `that don't have values: ${orphanComments.join(', ')}.`\n        );\n      }\n    } else {\n      throw new Error(`Unsupported file extension in file: ${options.filePath}`);\n    }\n\n    parseCache.set(fileCacheKey, { content: options.content, parsedFile });\n    return parsedFile;\n  }\n}\n"]}