"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsalBrowserTokenProvider = void 0;
var tslib_1 = require("tslib");
var msalBrowser = tslib_1.__importStar(require("@azure/msal-browser"));
var sp_core_library_1 = require("@microsoft/sp-core-library");
var AadConstants_1 = tslib_1.__importDefault(require("../../../AadConstants"));
var AadErrorHandler_1 = require("../../../AadErrorHandler");
var AadKillSwitches_1 = require("../../../AadKillSwitches");
var AadTokenProvider_1 = tslib_1.__importStar(require("../../../AadTokenProvider"));
var MsalInteractionManager_1 = require("../MsalInteractionManager");
var MsalMonitor_1 = require("../MsalMonitor");
var MsalRedirectManager_1 = require("../MsalRedirectManager");
var MsalUtilities_1 = require("../MsalUtilities");
var MsalBrowserClientManager_1 = require("./MsalBrowserClientManager");
/**
 * Class that wraps the MSAL Browser's authentication class in order to acquire tokens.
 *
 * MsalBrowserTokenProvider provides two methods to acquire tokens:
 *   1. getToken: returns a promise containing only the access token string.
 *   2. getTokenData: returns a promise containing the entire token object.
 *
 * @internal
 */
var MsalBrowserTokenProvider = /** @class */ (function () {
    function MsalBrowserTokenProvider(configuration) {
        this._ALLOWED_NETWORK_RETRY_ATTEMPTS = 1;
        this._defaultConfiguration = configuration;
        this._redirectManager = new MsalRedirectManager_1.MsalRedirectManager(this._getAuthority(), this._getClientId(), true);
        this._shouldPrintDebugLogs = MsalUtilities_1.MsalUtilities.shouldPrintMsalLogsToConsole();
        MsalBrowserClientManager_1.MsalBrowserClientManager.registerMsalBrowserClient(this._getAuthority(), this._getClientId(), this._getRedirectUri());
    }
    /**
     * This method wraps getTokenData() to extract only the access token from the response.
     * The access token is returned as a promise containing a string. If the entire token object
     * from MSAL is needed the caller should use getTokenData().
     *
     * The caller only needs to provide the resource they are requesting and the token provider
     * will use always use the scope '.default'. E.g.: "resourceEndpoint/.default".
     *
     * @param resourceEndpoint The endpoint the caller is requesting a resource from.
     * @returns A promise with only the access token (as a string) for the resource.
     */
    MsalBrowserTokenProvider.prototype.getToken = function (resourceEndpoint) {
        return this.getTokenData(resourceEndpoint).then(function (tokenData) { return tokenData.accessToken; });
    };
    /**
     * Gets an access token for the requested resource from MSAL. This method returns the entire token
     * object as a promise.
     *
     * This method will attempt to either invoke msalBrowser's ssoSilent() or acquireTokenSilent(). If
     * both of these calls fail, it will attempt to perform a redirect instead.
     *
     * Too many interactions too quickly with the MSAL client can put the MSAL cache in a bad state.
     * To avoid that, this method will always wait for MsalInteractionManager.acquireControl() to
     * resolve before continuing.
     *
     * AcquireControl() places this request in a queue that will either:
     *  - wait for the previous request to finish
     *  - continue after 10s
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @param useCachedToken Whether or not the token provider should use a cached token or fetch a new one.
     *                       Note: this paramater currently does not do anything. It exists in MSAL v1 and also
     *                             does not do anything there. I've included it here to maintain the same
     *                             function signature.
     * @param shouldNotLogOrRedirect If true, logging will be disabled and redirects will not occur.
     * @returns A promise containing entire token object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype.getTokenData = function (resourceEndpoint, useCachedToken, shouldNotLogOrRedirect) {
        var _this = this;
        if (useCachedToken === void 0) { useCachedToken = true; }
        if (shouldNotLogOrRedirect === void 0) { shouldNotLogOrRedirect = false; }
        this._shouldPrintDebugLogs = MsalUtilities_1.MsalUtilities.shouldPrintMsalLogsToConsole();
        var getTokenExtraData = this._generateTelemetryExtraData(resourceEndpoint);
        return this._ensureMsalClientIsInitialized(getTokenExtraData)
            .then(function () {
            _this._logger('getTokenData', 'Waiting for acquireControl().');
            return MsalInteractionManager_1.MsalInteractionManager.acquireControl();
        })
            .then(function () {
            _this._logger('getTokenData', 'acquireControl() successful, continuing.');
            var getTokenDataMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.GetTokenData', shouldNotLogOrRedirect);
            // If a correlation ID for the request is already provided in the configuartion, use that one.
            // Otherwise use the one generated by _genereateTelemetryExtraData().
            if (_this._defaultConfiguration.spRequestGuid) {
                getTokenExtraData.CorrelationId = _this._defaultConfiguration.spRequestGuid;
            }
            var tokenPromise;
            if (_this._isCurrentUserLoggedInToMsal()) {
                var acquireTokenSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.AcquireTokenSilent', shouldNotLogOrRedirect);
                var acquireTokenSilentExtraData = _this._generateTelemetryExtraData(resourceEndpoint);
                _this._logger('getTokenData', 'User is logged in, calling acquireTokenSilent().');
                tokenPromise = _this._acquireTokenSilent(resourceEndpoint, shouldNotLogOrRedirect, acquireTokenSilentMonitor, acquireTokenSilentExtraData);
            }
            else {
                var ssoSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.SsoSilent', shouldNotLogOrRedirect);
                var ssoSilentExtraData = _this._generateTelemetryExtraData(resourceEndpoint);
                _this._logger('getTokenData', 'No user is logged in, calling ssoSilent().');
                tokenPromise = _this._ssoSilent(resourceEndpoint, shouldNotLogOrRedirect, ssoSilentMonitor, ssoSilentExtraData);
            }
            return tokenPromise
                .then(function (tokenData) {
                _this._logger('getTokenData', 'Token retrieved. Exiting.');
                if (!(0, AadKillSwitches_1.isAddCacheHitsToGetTokenDataKillSwitch)()) {
                    getTokenExtraData.alias = (!!tokenData.fromCache).toString();
                }
                getTokenDataMonitor.writeSuccess(getTokenExtraData);
                MsalInteractionManager_1.MsalInteractionManager.releaseControl();
                return tokenData;
            })
                .catch(function (error) {
                _this._logger('getTokenData', 'Caught an error.', error);
                var canRedirect = _this._isErrorEligibleForRedirect(error) &&
                    _this._redirectManager.isAllowedToRedirect() &&
                    !shouldNotLogOrRedirect;
                if (canRedirect) {
                    _this._logger('getTokenData', 'Calling _loginRedirect()');
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, getTokenExtraData);
                    /* tslint:disable-next-line: no-floating-promises */
                    _this._loginRedirect(resourceEndpoint, getTokenExtraData);
                }
                else if (_this._isExpectedFailure(error)) {
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, getTokenExtraData);
                }
                else {
                    getTokenDataMonitor.writeUnexpectedFailure(error.errorCode, error, getTokenExtraData);
                }
                _this._logger('getTokenData', 'Throwing the error back to caller. Exiting.');
                MsalInteractionManager_1.MsalInteractionManager.releaseControl();
                throw error;
            });
        });
    };
    /**
     * Returns a promise that only resolves once the Msal Browser client has been initialized and assigned.
     * If the client hasn't been initialized, MsalBrowserClientManager will provide an initialized one.
     *
     * @param extraData Extra telemetry data for error reporting.
     * @returns The promise fulfils when this._msalBrowserClient has been initialized for use.
     */
    MsalBrowserTokenProvider.prototype._ensureMsalClientIsInitialized = function (extraData) {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this._msalBrowserClient) {
                resolve();
            }
            else {
                MsalBrowserClientManager_1.MsalBrowserClientManager.getMsalBrowserClient(_this._getAuthority(), _this._getClientId(), _this._getRedirectUri())
                    .then(function (msalBrowserClient) {
                    _this._msalBrowserClient = msalBrowserClient;
                    resolve();
                })
                    .catch(function (error) {
                    var msalClientInitializationQos = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider._ensureMsalClientIsInitialized');
                    msalClientInitializationQos.writeUnexpectedFailure('msalClientInit', error, extraData);
                });
            }
        });
    };
    /**
     * Wrapper method for msalBrowser.acquireTokenSilent(). This method is used when the current user is arleady
     * logged into to the msal-browser framework. It will retry if there are any detectable network issues
     * during msalBrowser.acquireTokenSilent().
     *
     * The token will be acquired from the cache or from the network using a refresh token. If this fails, the
     * error will be thrown to the calling method.
     *
     * The retry monitor is only invoked on retries and is considered failed each time an error has raised. The
     * acquireTokenSilentMonitor will be re-used on each retry.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @param shouldNotLog If set to true, logging will be skipped.
     * @param acquireTokenSilentMonitor The monitor tracking the request.
     * @param extraData Telemetry data for the specific request, including correlation ID.
     * @param attempt The current attempt number. This method may invoke itself in an attempt to retry.
     * @returns A promise containing the access token and full authentication response object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype._acquireTokenSilent = function (resourceEndpoint, shouldNotLog, acquireTokenSilentMonitor, extraData, attempt) {
        var _this = this;
        if (attempt === void 0) { attempt = 0; }
        var isFirstAttempt = attempt === 0;
        var retryAcquireTokenSilentMonitor;
        if (!isFirstAttempt) {
            retryAcquireTokenSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.RetryAcquireTokenSilent', shouldNotLog);
        }
        var silentRequest = this._generateSilentRequest(resourceEndpoint, extraData.CorrelationId);
        this._logger('_acquireTokenSilent', 'Calling acquireTokenSilent with parameters:', silentRequest);
        return this._msalBrowserClient
            .acquireTokenSilent(silentRequest)
            .then(function (authResult) {
            _this._logger('_acquireTokenSilent', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            acquireTokenSilentMonitor.writeSuccess(extraData);
            retryAcquireTokenSilentMonitor === null || retryAcquireTokenSilentMonitor === void 0 ? void 0 : retryAcquireTokenSilentMonitor.writeSuccess(extraData);
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_acquireTokenSilent', 'Caught an error:', error);
            retryAcquireTokenSilentMonitor === null || retryAcquireTokenSilentMonitor === void 0 ? void 0 : retryAcquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            var hasRetriesLeft = attempt < _this._ALLOWED_NETWORK_RETRY_ATTEMPTS;
            var isAllowedToRetry = _this._isNetworkError(error) && hasRetriesLeft;
            if (isAllowedToRetry) {
                attempt++;
                _this._logger('_acquireTokenSilent', 'Retrying.');
                return _this._acquireTokenSilent(resourceEndpoint, shouldNotLog, acquireTokenSilentMonitor, extraData, attempt);
            }
            else if (_this._isExpectedFailure(error)) {
                acquireTokenSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
            }
            else {
                acquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            }
            _this._logger('_acquireTokenSilent', 'Throwing error back to caller.');
            throw error;
        });
    };
    /**
     * Wrapper method for msalBrowser.ssoSilent(). This method is used when the current user is not logged
     * into to the msal-browser framework. It will retry if there are any detectable network issues during
     * msalBrowser.ssoSilent().
     *
     * The token will be acquired over the network and will use the current session ID if possible. If this
     * fails, the error will be thrown to the calling method.
     *
     * The retry monitor is only invoked on later attempts and is considered failed each time an error has
     * raised. The ssoSilentMonitor will be re-used on each retry.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @param shouldNotLog If set to true, no logging will be done and no redirects will occurr.
     * @param ssoSilentMonitor The monitor tracking the request.
     * @param extraData Telemetry data for the specific request, including correlation ID.
     * @param attempt The current attempt number. This method may invoke itself in an attempt to retry.
     * @returns A promise containing the access token and full authentication response object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype._ssoSilent = function (resourceEndpoint, shouldNotLog, ssoSilentMonitor, extraData, attempt) {
        var _this = this;
        if (attempt === void 0) { attempt = 0; }
        var isFirstAttempt = attempt === 0;
        var retrySsoSilentMonitor;
        if (!isFirstAttempt) {
            retrySsoSilentMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider.RetrySsoSilent', shouldNotLog);
        }
        var ssoSilentRequest = this._generateSsoSilentRequest(resourceEndpoint, extraData.CorrelationId);
        this._logger('_ssoSilent', 'Calling ssoSilent with parameters:', ssoSilentRequest);
        return this._msalBrowserClient
            .ssoSilent(ssoSilentRequest)
            .then(function (authResult) {
            _this._logger('_ssoSilent', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            ssoSilentMonitor.writeSuccess(extraData);
            retrySsoSilentMonitor === null || retrySsoSilentMonitor === void 0 ? void 0 : retrySsoSilentMonitor.writeSuccess(extraData);
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_ssoSilent', 'Caught an error:', error);
            retrySsoSilentMonitor === null || retrySsoSilentMonitor === void 0 ? void 0 : retrySsoSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            var hasRetriesLeft = attempt < _this._ALLOWED_NETWORK_RETRY_ATTEMPTS;
            var isAllowedToRetry = _this._isNetworkError(error) && hasRetriesLeft;
            if (isAllowedToRetry) {
                attempt++;
                _this._logger('_ssoSilent', 'Retrying.');
                return _this._ssoSilent(resourceEndpoint, shouldNotLog, ssoSilentMonitor, extraData, attempt);
            }
            else if (_this._isExpectedFailure(error)) {
                ssoSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
            }
            else {
                ssoSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            }
            _this._logger('_ssoSilent', 'Throwing error back to caller.');
            throw error;
        });
    };
    /**
     * This method wraps msal-browser's loginRedirect method. This method must call
     * MalBrowserRedirectManager.prepareForRedirect(). This ensures that the redirect page,
     * spfxsinglesignon.aspx, will know how to properly instantiate and configure msal-browser.
     *
     * This method returns nothing and immediately redirects.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @returns Nothing. This method will immediately perform a redirect.
     */
    MsalBrowserTokenProvider.prototype._loginRedirect = function (resourceEndpoint, extraData) {
        var _this = this;
        var loginRedirectRequestData = this._generateLoginRedirectRequest(resourceEndpoint, extraData.CorrelationId);
        this._logger('_loginRedirect', 'Calling prepareForRedirect().');
        this._redirectManager.prepareForRedirect();
        this._logger('_loginRedirect', 'Calling loginRedirect.');
        return this._msalBrowserClient.loginRedirect(loginRedirectRequestData).catch(function (error) {
            _this._logger('_loginRedirect', 'Failed to redirect with error:', error);
            var loginRedirectMonitor = new MsalMonitor_1.MsalMonitor('MsalBrowserTokenProvider._loginRedirect');
            loginRedirectMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            throw error;
        });
    };
    /**
     * Generates an MSAL SilentRequest to be used with the loginSilent method.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @param correlationId The correlation ID of the request
     * @returns An MSAL SilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateSilentRequest = function (resourceEndpoint, correlationId) {
        var silentRequestData = {
            account: this._getCurrentAccount(),
            authority: this._getAuthority(),
            correlationId: correlationId,
            scopes: this._getScopes(resourceEndpoint)
        };
        return silentRequestData;
    };
    /**
     * Generates an MSAL SsoSilentRequest to be used with the ssoSilent method.
     * Note: SID and login hint may be undefined if they are non-existant or invalid. This
     *       may cause the request to fail and be handled by a redirect instead.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @param correlationId The correlation ID of the request
     * @returns An MSAL SsoSilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateSsoSilentRequest = function (resourceEndpoint, correlationId) {
        var ssoSilentRequestData = {
            authority: this._getAuthority(),
            correlationId: correlationId,
            loginHint: this._getLoginHint(),
            scopes: this._getScopes(resourceEndpoint),
            sid: this._getSessionId()
        };
        return ssoSilentRequestData;
    };
    /**
     * Generates telemetry data to be added to QoS Monitors. We track:
     * - alias: Marks cache hits. This will be true if the request came from the cache.
     *          This is called 'alias' to remain consistent with MSAL v1.
     * - CorrelationId: The correlation ID of the token request.
     * - isInternal: Marks first party applications. This will be true if the application is first party.
     * - jsonExtraData: Bucket for MSAL.js request specific data such as event time, name, etc.
     *                  msal-browser currently does not provide this data so this will just be an empty string.
     *                  msal-browser will eventually add in this API telemetry data similar to MSAL v1.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @returns An IMsalTokenProviderExtraData object that can be added to QoS Monitor writes.
     */
    MsalBrowserTokenProvider.prototype._generateTelemetryExtraData = function (resourceEndpoint) {
        var isInternal = this._defaultConfiguration.servicePrincipalId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID;
        var extraData = {
            alias: 'false',
            CorrelationId: sp_core_library_1.Guid.newGuid().toString(),
            isInternal: isInternal,
            jsonExtraData: ''
        };
        if (isInternal) {
            extraData.name = resourceEndpoint;
        }
        return extraData;
    };
    /**
     * Given an error, this method will return true if the token provider is allowed to redirect
     * and the error can be solved with a redirect.
     *
     * Note: Redirects are not performed for IE.
     *
     * @param error An msalBrowser AuthError.
     * @returns True if the error can be solved with a redirect and there are remaining redirects.
     */
    MsalBrowserTokenProvider.prototype._isErrorEligibleForRedirect = function (error) {
        var hasMoreRedirectAttempts = this._redirectManager.hasRedirectAttemptsLeft();
        var isInteractionRequiredError = this._isInteractionRequiredError(error);
        var isBrowserIE = sp_core_library_1._BrowserDetection.getBrowserInformation().browser === sp_core_library_1._Browser.IE;
        var isAbleToRedirect = isInteractionRequiredError && hasMoreRedirectAttempts && !isBrowserIE;
        return isAbleToRedirect;
    };
    /**
     * Given an error, this method will return true if the provided error is any type of 'Interaction Required'
     * error. These errors can be solved by invoking a full-page redirect (interaction).
     *
     * @param error An msal-browser AuthError.
     * @returns True if the error provided can be solved by a redirect and false otherwise.
     */
    MsalBrowserTokenProvider.prototype._isInteractionRequiredError = function (error) {
        return (error instanceof msalBrowser.InteractionRequiredAuthError ||
            AadErrorHandler_1.AadErrorHandler._isInteractionRequired(error.message, error.errorCode) ||
            error.errorCode === 'no_account_error');
    };
    /**
     * Given an msal-browser AuthError, returns true if the error is an expected failure for QoS Monitors.
     * These errors can either be ignored (i.e., TabStop test) or solved by a full-page redirect (as long as
     * there are redirect attempts remaining).
     *
     * @param error An msal-browser AuthError.
     * @returns True if the error is expected and be recorded as successful for QoS Monitors.
     */
    MsalBrowserTokenProvider.prototype._isExpectedFailure = function (error) {
        var canAttemptRedirect = this._isErrorEligibleForRedirect(error);
        var doesAadErrorCodeExist = AadErrorHandler_1.AadErrorHandler._doesAadErrorCodeExist(error.message, AadConstants_1.default.EXPECTED_AAD_ERRORS);
        var isTabStopTest = this._isTabStopTest();
        return canAttemptRedirect || doesAadErrorCodeExist || isTabStopTest;
    };
    /**
     * This method returns true if a TabStop test is currently being run. TabStop tests are
     * known to cause issues and so they are generally recorded as expected failures.
     *
     * @returns True if a TabStop test is running.
     */
    MsalBrowserTokenProvider.prototype._isTabStopTest = function () {
        var userAgentString = sp_core_library_1._BrowserDetection.getBrowserInformation().userAgent || '';
        var isTabStopTest = userAgentString.indexOf('TabStop/1.0') > -1;
        return isTabStopTest;
    };
    /**
     * Generates an MSAL RedirectRequest to be used with the loginRedirect method.
     *
     * @param resourceEndpoint The resource a token is being requested for.
     * @param correlationId The correlation ID of the request
     * @returns An MSAL RedirectRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateLoginRedirectRequest = function (resourceEndpoint, correlationId) {
        var redirectRequestData = {
            authority: this._getAuthority(),
            correlationId: correlationId,
            onRedirectNavigate: this._getOnRedirectNavigate(),
            redirectUri: this._getRedirectUri(),
            scopes: this._getScopes(resourceEndpoint),
            state: window.location.href
        };
        return redirectRequestData;
    };
    /**
     * This method is used to retrieve the callback for the onRedirectNagivate option on MSAL RedirectRequests.
     * If this method returns false, then MSAL will cancel the redirect. This method raises an event
     * that gives the method requesting a token the opportunity to cancel the redirect.
     *
     * Note: This method returns a method in order to correctly bind 'this'. If
     *       onRedirectNavigateCallback was a class-level method and included
     *       in a RedirectRequest as a parameter, 'this' fails to bind and
     *       throw a runtime error.
     *
     * @param url The URL that MSAL will attempt to redirect to.
     * @returns Returning false will cancel the redirect.
     */
    MsalBrowserTokenProvider.prototype._getOnRedirectNavigate = function () {
        var _this = this;
        var onRedirectNagivateCallback = function (url) {
            _this._redirectCancelled = false;
            sp_core_library_1._SPEventManager.instance.raiseEvent(AadTokenProvider_1.default._onBeforeRedirectEventId, new AadTokenProvider_1.BeforeRedirectEventArgs(url, _this._cancelRedirect.bind(_this)));
            // If we are in tab cancel the redirect.
            if (window.sessionStorage.getItem('_isRunningTABTest') === 'true') {
                _this._redirectCancelled = true;
            }
            if (_this._redirectCancelled) {
                _this._redirectManager.cancelRedirect();
            }
            return !_this._redirectCancelled;
        };
        return onRedirectNagivateCallback;
    };
    /**
     * Attempts to retrieve the current user account logged into the MSAL framework. The userPrincipalName
     * from the configuration object is used to determine if the account is logged in. This will return
     * undefined if no account is logged in.
     *
     * @returns An MSAL AccountInfo object of the currently logged in user or undefined if there is no
     *          logged in user.
     */
    MsalBrowserTokenProvider.prototype._getCurrentAccount = function () {
        var userName = this._defaultConfiguration.userPrincipalName || '';
        var localId = this._defaultConfiguration.aadUserId || '';
        var currentAccountByUsername = this._msalBrowserClient.getAccountByUsername(userName);
        var currentAccountByLocalId = this._msalBrowserClient.getAccountByLocalId(localId);
        var currentActiveAccount = this._msalBrowserClient.getActiveAccount();
        if (currentAccountByUsername || currentAccountByLocalId) {
            this._logger('_getCurrentAccount', 'Found an account', {
                currentAccountByLocalId: currentAccountByLocalId,
                currentAccountByUsername: currentAccountByUsername
            });
        }
        else {
            this._logger('_getCurrentAccount', 'No account found');
        }
        return currentAccountByUsername || currentAccountByLocalId || currentActiveAccount || undefined;
    };
    /**
     * This method is used to cancel redirects. It is binded to an event raised before full page redirects
     * so that the method requesting a token may choose to cancel the redirect if necessary by calling this.
     * By default redirects are turned on.
     */
    MsalBrowserTokenProvider.prototype._cancelRedirect = function () {
        this._redirectCancelled = true;
    };
    /**
     * This method returns whether or not a given error is a retriable network related error.
     *
     * @param error An MSAL error code.
     * @returns Whether or not the error is network related.
     */
    MsalBrowserTokenProvider.prototype._isNetworkError = function (error) {
        return (AadErrorHandler_1.AadErrorHandler._isEndpointsResolutionError(error === null || error === void 0 ? void 0 : error.errorCode) ||
            AadErrorHandler_1.AadErrorHandler._isTokenRenewalTimeout(error === null || error === void 0 ? void 0 : error.errorCode));
    };
    /**
     * Using the userPrincipalName from the configuration object, returns whether or not the user is logged
     * into the MSAL framework.
     *
     * @returns True if the current user is logged into the MSAL framework.
     */
    MsalBrowserTokenProvider.prototype._isCurrentUserLoggedInToMsal = function () {
        return this._getCurrentAccount() !== undefined;
    };
    /**
     * Using the configuration object passed to the token provider, assembles and returns the 'authority' string
     * to be used in MSAL requests.
     *
     * @returns The 'authority' string to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getAuthority = function () {
        return this._defaultConfiguration.aadInstanceUrl + '/' + this._defaultConfiguration.aadTenantId;
    };
    /**
     * Using the userPrincipalName from the configuration object passed to the token provider, returns the
     * 'loginHint' string to be used in MSAL requests.
     *
     * @returns The 'loginHint' string to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getLoginHint = function () {
        return this._defaultConfiguration.userPrincipalName;
    };
    /**
     * Given the resource a token is being requested for, returns the 'scopes' array to be used in MSAL
     * requests. Scopes are always returned as a single string in an array, where the scope requested is the
     * default scope.
     *
     * This scope will provide access to all preauthorized scopes and does not provide granular scope access.
     *
     * Example:
     *   resourceEndpoint: contoso.sharepoint.com
     *   returns: ['contoso.sharepoint.com/.default']
     *
     * @param resourceEndpoint The resource a token is being requested for
     * @returns A scope array to be used with MSAL requests for the given resource.
     */
    MsalBrowserTokenProvider.prototype._getScopes = function (resourceEndpoint) {
        return [resourceEndpoint + '/.default'];
    };
    /**
     * Using the aadSessionId from the configuration object passed to the token provider, returns the 'sid'
     * string to be used in MSAL requests. If the session ID is not a valid GUID or does not exist, this
     * will return undefined.
     *
     * Note: A value of undefined may result in requiring a full page redirect.
     *
     * @returns The 'sid' field to be used in MSAL requests or undefined.
     */
    MsalBrowserTokenProvider.prototype._getSessionId = function () {
        var sessionId = this._defaultConfiguration.aadSessionId;
        var isValidSessionId = !!sp_core_library_1.Guid.tryParse(sessionId);
        if (!isValidSessionId) {
            sessionId = undefined;
        }
        if (sessionId) {
            this._logger('_getSessionId', 'Found session ID', sessionId);
        }
        else {
            this._logger('_getSessionId', 'No session ID was found');
        }
        return sessionId;
    };
    /**
     * Using the servicePrincipalId from the configuration object passed to the token provider, returns the
     * 'clientId' string to be used in MSAL requests.
     *
     * @returns The 'clientId' field to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getClientId = function () {
        return this._defaultConfiguration.servicePrincipalId;
    };
    /**
     * Using the redirectUri from the configuration object passed to the token provider, returns the
     * 'redirectUri' string to be used in MSAL requests.
     *
     * @returns The 'redirectUri' field to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getRedirectUri = function () {
        return this._defaultConfiguration.redirectUri;
    };
    /**
     * Logger for debugging. If the query string parameter 'msalLogging=true' is present,
     * logs will be printed to the console.
     */
    /* tslint:disable-next-line: no-any */
    MsalBrowserTokenProvider.prototype._logger = function (fnName, message, extraData) {
        if (this._shouldPrintDebugLogs) {
            console.log('[sp-http][MsalBrowserTokenProvider][' + fnName + '][1]: ' + message);
            if (extraData) {
                console.log('[sp-http][MsalBrowserTokenProvider][' + fnName + '][2] Extra Data: ');
                console.log(extraData);
            }
        }
    };
    return MsalBrowserTokenProvider;
}());
exports.MsalBrowserTokenProvider = MsalBrowserTokenProvider;
//# sourceMappingURL=MsalBrowserTokenProvider.js.map